[1mdiff --git a/api/core/models.py b/api/core/models.py[m
[1mindex d530673..bf74edd 100644[m
[1m--- a/api/core/models.py[m
[1m+++ b/api/core/models.py[m
[36m@@ -1,11 +1,9 @@[m
 from rest_framework import serializers[m
 from django.contrib.postgres.fields import JSONField[m
 from django.db.models import ([m
[31m-    AutoField,[m
     BooleanField,[m
     DateTimeField,[m
     CharField,[m
[31m-    ForeignKey,[m
     IntegerField,[m
     TextField,[m
     FloatField,[m
[36m@@ -125,9 +123,6 @@[m [mclass TournamentDefinition(Model):[m
     repetitions = IntegerField()[m
     noise = FloatField()[m
     with_morality = BooleanField()[m
[31m-    player_list = serializers.ListField(child=serializers.CharField())[m
[31m-    players = [][m
[31m-[m
     # Relationship Fields[m
     # tournament = ForeignKey('Tournament',)[m
 [m
[36m@@ -135,5 +130,3 @@[m [mclass TournamentDefinition(Model):[m
 class MatchDefinition(Model):[m
     turns = IntegerField()[m
     noise = FloatField()[m
[31m-    player_list = serializers.ListField(child=serializers.CharField())[m
[31m-    players = [][m
[1mdiff --git a/api/core/serializers.py b/api/core/serializers.py[m
[1mindex aed00b9..29133ef 100644[m
[1m--- a/api/core/serializers.py[m
[1m+++ b/api/core/serializers.py[m
[36m@@ -1,8 +1,5 @@[m
[31m-import inspect[m
[31m-import json[m
 from rest_framework import serializers[m
 from rest_framework.reverse import reverse[m
[31m-from rest_framework.response import Response[m
 [m
 from . import models[m
 [m
[36m@@ -12,6 +9,10 @@[m [mdef strategy_id(strategy):[m
 [m
 [m
 class StrategySerializer(serializers.Serializer):[m
[32m+[m[32m    """[m
[32m+[m[32m    Serialize an axelrod strategy object based on[m
[32m+[m[32m    introspection into its class attributes[m
[32m+[m[32m    """[m
     url = serializers.SerializerMethodField()[m
     id = serializers.SerializerMethodField()[m
     name = serializers.CharField(max_length=200)[m
[36m@@ -34,61 +35,114 @@[m [mclass StrategySerializer(serializers.Serializer):[m
 [m
     def get_classifier(self, strategy):[m
         classifier = strategy.classifier[m
[32m+[m[32m        # float('inf') is not valid json[m
         if classifier['memory_depth'] == float('inf'):[m
             classifier['memory_depth'] = -1[m
         return classifier[m
 [m
     def get_params(self, strategy):[m
         params = strategy.init_params()[m
[32m+[m[32m        # float('inf') is not valid json[m
         if 'memory_depth' in params and params['memory_depth'] == float('inf'):[m
             params['memory_depth'] = -1[m
         return params[m
 [m
 [m
[32m+[m[32mclass StringListField(serializers.ListField):[m
[32m+[m[32m    child = serializers.CharField(trim_whitespace=True)[m
[32m+[m
[32m+[m
 class TournamentSerializer(serializers.ModelSerializer):[m
[32m+[m[32m    player_list = StringListField(min_length=2, max_length=None)[m
 [m
     class Meta:[m
         model = models.TournamentDefinition[m
         fields = ('name', 'created', 'last_updated', 'turns',[m
[31m-                  'repetitions', 'noise', 'with_morality', 'players')[m
[32m+[m[32m                  'repetitions', 'noise', 'with_morality', 'player_list')[m
 [m
 [m
 class MatchSerializer(serializers.ModelSerializer):[m
[32m+[m[32m    player_list = StringListField(min_length=2, max_length=2)[m
 [m
     class Meta:[m
         model = models.MatchDefinition[m
[31m-        fields = ('turns', 'noise', 'players')[m
[32m+[m[32m        fields = ('turns', 'noise', 'player_list')[m
 [m
 [m
 class ResultsSerializer:[m
[31m-[m
[31m-    data = None[m
[32m+[m[32m    """[m
[32m+[m[32m    Serialize an axelrod ResultSet class into a dictionary by[m
[32m+[m[32m    iterating over its __dict__ method.[m
[32m+[m
[32m+[m[32m    For complex objects (Game, State objects) more in depth serialization[m
[32m+[m[32m    is required - these are handled in separate methods. For example the[m
[32m+[m[32m    state_distribution_keys are[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    # TODO implement state_distribution serializations[m
[32m+[m[32m    state_distribution_keys = [[m
[32m+[m[32m        'state_distribution',[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32m    # keys that have not been implemented[m
[32m+[m[32m    ignore_keys = [[m
[32m+[m[32m        'normalised_state_distribution',[m
[32m+[m[32m        'state_to_action_distribution',[m
[32m+[m[32m        'normalised_state_to_action_distribution',[m
[32m+[m[32m        'game',[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32m    # keys where the value is not json serializable[m
[32m+[m[32m    invalid_keys = [[m
[32m+[m[32m        'progress_bar'[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32m    # keys we should not retrieve from __dict__ method[m
[32m+[m[32m    exclude = state_distribution_keys + ignore_keys + invalid_keys[m
 [m
     def __init__(self, results):[m
[31m-        results_object = self.serialize_state_distributions(results)[m
[32m+[m[32m        """[m
[32m+[m[32m        Parameters[m
[32m+[m[32m        ----------[m
[32m+[m[32m            results: ResultSet:[m
[32m+[m[32m                https://github.com/Axelrod-Python/Axelrod/blob/master/axelrod/result_set.py[m
[32m+[m[32m        """[m
[32m+[m[32m        response_object = self.serialize_state_distributions(results)[m
         for key, value in results.__dict__.items():[m
[31m-            try:[m
[31m-                json.dumps(key)[m
[31m-                json.dumps(value)[m
[31m-                results_object[key] = value[m
[31m-            except TypeError:[m
[31m-                pass[m
[31m-        self.data = results_object[m
[32m+[m[32m            if key not in self.exclude:[m
[32m+[m[32m                response_object[key] = value[m
[32m+[m[32m        # we mimic DRF serializer by setting data property instead of returning[m
[32m+[m[32m        self.data = response_object[m
 [m
     def serialize_state_distributions(self, results):[m
[31m-        keys = [[m
[31m-            'state_distribution',[m
[31m-            'normalised_state_distribution',[m
[31m-            'state_to_action_distribution',[m
[31m-            'normalised_state_to_action_distribution'[m
[31m-        ][m
[32m+[m[32m        """[m
[32m+[m[32m        Initialize the response_object dictionary and set in it a[m
[32m+[m[32m        set of lists that contain serialized Counter objects[m
[32m+[m
[32m+[m[32m        Parameters[m
[32m+[m[32m        ----------[m
[32m+[m
[32m+[m[32m            results: ResultSet[m
[32m+[m[32m                results from a Tournament/Match[m
[32m+[m[32m        """[m
         return {[m
             key: self.serialize_state_distribution(getattr(results, key))[m
[31m-            for key in keys[m
[32m+[m[32m            for key in self.state_distribution_keys[m
         }[m
 [m
[31m-    def serialize_state_distribution(self, state_distribution):[m
[32m+[m[32m    @staticmethod[m
[32m+[m[32m    def serialize_state_distribution(state_distribution):[m
[32m+[m[32m        """[m
[32m+[m[32m        Iterate over a state distribution and serialize all of[m
[32m+[m[32m        its Counter objects[m
[32m+[m
[32m+[m[32m        Parameters[m
[32m+[m[32m        ----------[m
[32m+[m
[32m+[m[32m            state_distribution: list of Counter[m
[32m+[m[32m                state_distribution from ResultSet[m
[32m+[m[32m        """[m
         distribution = [][m
[31m-        for row in state_distribution:[m
[31m-            distribution.append([c.most_common() for c in row])[m
[32m+[m[32m        for counter in state_distribution:[m
[32m+[m[32m            distribution.append([c.most_common() for c in counter])[m
         return distribution[m
[1mdiff --git a/api/core/tests/test_serializers.py b/api/core/tests/test_serializers.py[m
[1mindex 66fb32d..a802435 100644[m
[1m--- a/api/core/tests/test_serializers.py[m
[1m+++ b/api/core/tests/test_serializers.py[m
[36m@@ -1,7 +1,13 @@[m
 from unittest import TestCase[m
[32m+[m[32mimport axelrod as axl[m
 from rest_framework.test import APIRequestFactory[m
 [m
[31m-from api.core.serializers import StrategySerializer[m
[32m+[m[32mfrom api.core.serializers import ([m
[32m+[m[32m    MatchSerializer,[m
[32m+[m[32m    ResultsSerializer,[m
[32m+[m[32m    StrategySerializer,[m
[32m+[m[32m    TournamentSerializer,[m
[32m+[m[32m)[m
 [m
 [m
 class TestStrategy(object):[m
[36m@@ -25,7 +31,7 @@[m [mclass TestStrategy(object):[m
         return self.params[m
 [m
 [m
[31m-class TestSerializers(TestCase):[m
[32m+[m[32mclass TestStrategySerializer(TestCase):[m
 [m
     @classmethod[m
     def setUpClass(cls):[m
[36m@@ -53,3 +59,112 @@[m [mclass TestSerializers(TestCase):[m
         serializer = StrategySerializer(self.strategy, context={'request': self.request})[m
         self.assertEqual(-1, serializer.data['classifier']['memory_depth'])[m
 [m
[32m+[m
[32m+[m[32mclass TestTournamentSerializer(TestCase):[m
[32m+[m
[32m+[m[32m    @classmethod[m
[32m+[m[32m    def setUpClass(cls):[m
[32m+[m[32m        cls.valid_post_data = {[m
[32m+[m[32m            'name': 'test_tournament',[m
[32m+[m[32m            'turns': 5,[m
[32m+[m[32m            'repetitions': 2,[m
[32m+[m[32m            'noise': 0.1,[m
[32m+[m[32m            'with_morality': False,[m
[32m+[m[32m            'player_list': ['test1', 'test2'][m
[32m+[m[32m        }[m
[32m+[m[32m        cls.missing_name = {[m
[32m+[m[32m            'turns': 5,[m
[32m+[m[32m            'repetitions': 2,[m
[32m+[m[32m            'noise': 0.1,[m
[32m+[m[32m            'with_morality': False,[m
[32m+[m[32m            'player_list': ['test1', 'test2'][m
[32m+[m[32m        }[m
[32m+[m[32m        cls.invalid_field_values = {[m
[32m+[m[32m            'name': 'test_tournament',[m
[32m+[m[32m            'turns': 5,[m
[32m+[m[32m            'repetitions': 2,[m
[32m+[m[32m            'noise': 0.1,[m
[32m+[m[32m            'with_morality': False,[m
[32m+[m[32m            'player_list': ['test'][m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    def test_is_valid_with_all_fields(self):[m
[32m+[m[32m        serializer = TournamentSerializer(data=self.valid_post_data)[m
[32m+[m[32m        self.assertTrue(serializer.is_valid())[m
[32m+[m
[32m+[m[32m    def test_is_invalid_with_missing_fields(self):[m
[32m+[m[32m        serializer = TournamentSerializer(data=self.missing_name)[m
[32m+[m[32m        self.assertFalse(serializer.is_valid())[m
[32m+[m[32m        self.assertEqual({'name': ['This field is required.']}, serializer.errors)[m
[32m+[m
[32m+[m[32m    def test_is_invalid_with_incorrect_value(self):[m
[32m+[m[32m        serializer = TournamentSerializer(data=self.invalid_field_values)[m
[32m+[m[32m        self.assertFalse(serializer.is_valid())[m
[32m+[m[32m        self.assertEqual({[m
[32m+[m[32m            'player_list': ['Ensure this field has at least 2 elements.'][m
[32m+[m[32m        }, serializer.errors)[m
[32m+[m
[32m+[m
[32m+[m[32mclass TestMatchSerializer(TestCase):[m
[32m+[m
[32m+[m[32m    @classmethod[m
[32m+[m[32m    def setUpClass(cls):[m
[32m+[m[32m        cls.valid_post_data = {[m
[32m+[m[32m            'turns': 5,[m
[32m+[m[32m            'noise': 0.1,[m
[32m+[m[32m            'player_list': ['test1', 'test2'][m
[32m+[m[32m        }[m
[32m+[m[32m        cls.missing_turns = {[m
[32m+[m[32m            'noise': 0.1,[m
[32m+[m[32m            'player_list': ['test1', 'test2'][m
[32m+[m[32m        }[m
[32m+[m[32m        cls.invalid_field_values = {[m
[32m+[m[32m            'turns': 5,[m
[32m+[m[32m            'noise': 0.1,[m
[32m+[m[32m            'player_list': ['test1'][m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    def test_is_valid_with_all_fields(self):[m
[32m+[m[32m        serializer = MatchSerializer(data=self.valid_post_data)[m
[32m+[m[32m        self.assertTrue(serializer.is_valid())[m
[32m+[m
[32m+[m[32m    def test_is_invalid_with_missing_fields(self):[m
[32m+[m[32m        serializer = MatchSerializer(data=self.missing_turns)[m
[32m+[m[32m        self.assertFalse(serializer.is_valid())[m
[32m+[m[32m        self.assertEqual({'turns': ['This field is required.']}, serializer.errors)[m
[32m+[m
[32m+[m[32m    def test_is_invalid_with_incorrect_value(self):[m
[32m+[m[32m        serializer = MatchSerializer(data=self.invalid_field_values)[m
[32m+[m[32m        self.assertFalse(serializer.is_valid())[m
[32m+[m[32m        self.assertEqual({[m
[32m+[m[32m            'player_list': ['Ensure this field has at least 2 elements.'][m
[32m+[m[32m        }, serializer.errors)[m
[32m+[m
[32m+[m
[32m+[m[32mclass TestResultSerializer(TestCase):[m
[32m+[m
[32m+[m[32m    @classmethod[m
[32m+[m[32m    def setUpClass(cls):[m
[32m+[m[32m        players = [axl.Alternator(), axl.TitForTat()][m
[32m+[m[32m        tournament = axl.Tournament(players)[m
[32m+[m[32m        cls.results = tournament.play()[m
[32m+[m[32m        cls.data = ResultsSerializer(cls.results).data[m
[32m+[m[32m        cls.expected_keys = [[m
[32m+[m[32m            'filename', 'num_interactions', 'players', 'repetitions',[m
[32m+[m[32m            'nplayers', 'match_lengths', 'wins', 'scores', 'normalised_scores',[m
[32m+[m[32m            'payoffs', 'score_diffs', 'cooperation', 'normalised_cooperation',[m
[32m+[m[32m            'initial_cooperation_count', 'good_partner_matrix', 'total_interactions',[m
[32m+[m[32m            'good_partner_rating', 'ranking', 'ranked_names', 'payoff_matrix',[m
[32m+[m[32m            'payoff_stddevs', 'payoff_diffs_means', 'vengeful_cooperation',[m
[32m+[m[32m            'cooperating_rating', 'initial_cooperation_rate', 'eigenjesus_rating',[m
[32m+[m[32m            'eigenmoses_rating', 'wins', 'state_distribution'[m
[32m+[m[32m        ][m
[32m+[m
[32m+[m[32m    def test_data_keys_in_expected(self):[m
[32m+[m[32m        for data_key, value in self.data.items():[m
[32m+[m[32m            self.assertIn(data_key, self.expected_keys)[m
[32m+[m
[32m+[m[32m    def test_only_expected_in_data(self):[m
[32m+[m[32m        for expected_key in self.expected_keys:[m
[32m+[m[32m            self.assertIn(expected_key, self.data)[m
[32m+[m
[1mdiff --git a/api/core/tests/test_views.py b/api/core/tests/test_views.py[m
[1mindex fee5a82..10e923a 100644[m
[1m--- a/api/core/tests/test_views.py[m
[1m+++ b/api/core/tests/test_views.py[m
[36m@@ -1,13 +1,16 @@[m
[32m+[m[32mimport json[m
 from unittest import TestCase, mock[m
 from rest_framework.test import APIClient[m
 [m
 from api.core.serializers import strategy_id[m
 [m
[32m+[m
 class TestStrategy(object):[m
 [m
     def __init__(self, name, classifier):[m
         self.name = name[m
         self.classifier = classifier[m
[32m+[m
     def init_params(self):[m
         return {}[m
 [m
[36m@@ -44,4 +47,142 @@[m [mclass TestStrategyView(TestCase):[m
         self.assertEqual(404, response.status_code)[m
 [m
 [m
[32m+[m[32mclass TestTournamentView(TestCase):[m
[32m+[m
[32m+[m[32m    @classmethod[m
[32m+[m[32m    def setUpClass(cls):[m
[32m+[m[32m        cls.valid_post_data = {[m
[32m+[m[32m            'name': 'tournament',[m
[32m+[m[32m            'turns': 5,[m
[32m+[m[32m            'repetitions': 2,[m
[32m+[m[32m            'noise': 0.1,[m
[32m+[m[32m            'with_morality': False,[m
[32m+[m[32m            'player_list': ["adaptive", "allcoralld", "adaptive", "anticycler"],[m
[32m+[m[32m        }[m
[32m+[m[32m        cls.no_strategy_found = {[m
[32m+[m[32m            'name': 'tournament',[m
[32m+[m[32m            'turns': 5,[m
[32m+[m[32m            'repetitions': 2,[m
[32m+[m[32m            'noise': 0.1,[m
[32m+[m[32m            'with_morality': False,[m
[32m+[m[32m            'player_list': ["adapt"],[m
[32m+[m[32m        }[m
[32m+[m[32m        cls.missing_name = {[m
[32m+[m[32m            'turns': 5,[m
[32m+[m[32m            'repetitions': 2,[m
[32m+[m[32m            'noise': 0.1,[m
[32m+[m[32m            'with_morality': False,[m
[32m+[m[32m            'player_list': ["adaptive", "allcoralld", "adaptive", "anticycler"],[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    def setUp(self):[m
[32m+[m[32m        self.client = APIClient()[m
[32m+[m
[32m+[m[32m    @mock.patch('api.core.views.ResultsSerializer')[m
[32m+[m[32m    @mock.patch('api.core.views.axl.Tournament.play')[m
[32m+[m[32m    def test_tournament_played(self, play, serializer):[m
[32m+[m[32m        mock_object = mock.MagicMock[m
[32m+[m[32m        mock_object.data = 'test'[m
[32m+[m
[32m+[m[32m        serializer.return_value = mock_object()[m
[32m+[m[32m        response = self.client.post('/tournaments/',[m
[32m+[m[32m                                    json.dumps(self.valid_post_data),[m
[32m+[m[32m                                    content_type='application/json')[m
[32m+[m[32m        self.assertEqual(201, response.status_code)[m
[32m+[m[32m        self.assertEqual(1, serializer.call_count)[m
[32m+[m
[32m+[m[32m    @mock.patch('api.core.views.ResultsSerializer')[m
[32m+[m[32m    @mock.patch('api.core.views.axl.Tournament.play')[m
[32m+[m[32m    def test_strategy_not_found(self, play, serializer):[m
[32m+[m[32m        mock_object = mock.MagicMock[m
[32m+[m[32m        mock_object.data = 'test'[m
[32m+[m
[32m+[m[32m        serializer.return_value = mock_object()[m
[32m+[m[32m        response = self.client.post('/tournaments/',[m
[32m+[m[32m                                    json.dumps(self.no_strategy_found),[m
[32m+[m[32m                                    content_type='application/json')[m
[32m+[m[32m        self.assertEqual(400, response.status_code)[m
[32m+[m[32m        self.assertEqual({[m
[32m+[m[32m            'player_list': ['Ensure this field has at least 2 elements.']},[m
[32m+[m[32m            response.data)[m
[32m+[m
[32m+[m[32m    @mock.patch('api.core.views.ResultsSerializer')[m
[32m+[m[32m    @mock.patch('api.core.views.axl.Tournament.play')[m
[32m+[m[32m    def test_invalid_field(self, play, serializer):[m
[32m+[m[32m        mock_object = mock.MagicMock[m
[32m+[m[32m        mock_object.data = 'test'[m
[32m+[m
[32m+[m[32m        serializer.return_value = mock_object()[m
[32m+[m[32m        response = self.client.post('/tournaments/',[m
[32m+[m[32m                                    json.dumps(self.missing_name),[m
[32m+[m[32m                                    content_type='application/json')[m
[32m+[m[32m        self.assertEqual(400, response.status_code)[m
[32m+[m[32m        self.assertEqual({'name': ['This field is required.']}, response.data)[m
[32m+[m
[32m+[m
[32m+[m[32mclass TestMatchView(TestCase):[m
[32m+[m
[32m+[m[32m    @classmethod[m
[32m+[m[32m    def setUpClass(cls):[m
[32m+[m[32m        cls.valid_post_data = {[m
[32m+[m[32m            'turns': 5,[m
[32m+[m[32m            'noise': 0.1,[m
[32m+[m[32m            'player_list': ["adaptive", "allcoralld"],[m
[32m+[m[32m        }[m
[32m+[m[32m        cls.no_strategy_found = {[m
[32m+[m[32m            'turns': 5,[m
[32m+[m[32m            'noise': 0.1,[m
[32m+[m[32m            'player_list': ["adapt"],[m
[32m+[m[32m        }[m
[32m+[m[32m        cls.missing_noise = {[m
[32m+[m[32m            'turns': 5,[m
[32m+[m[32m            'player_list': ["adaptive", "allcoralld"],[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    def setUp(self):[m
[32m+[m[32m        self.client = APIClient()[m
[32m+[m
[32m+[m[32m    @mock.patch('api.core.views.ResultsSerializer')[m
[32m+[m[32m    @mock.patch('api.core.views.axl.Match.play')[m
[32m+[m[32m    def test_match_played(self, play, serializer):[m
[32m+[m[32m        mock_object = mock.MagicMock[m
[32m+[m[32m        mock_object.data = 'test'[m
[32m+[m
[32m+[m[32m        serializer.return_value = mock_object()[m
[32m+[m[32m        response = self.client.post('/matches/',[m
[32m+[m[32m                                    json.dumps(self.valid_post_data),[m
[32m+[m[32m                                    content_type='application/json')[m
[32m+[m[32m        self.assertEqual(1, serializer.call_count)[m
[32m+[m[32m        self.assertEqual(201, response.status_code)[m
[32m+[m
[32m+[m[32m    @mock.patch('api.core.views.ResultsSerializer')[m
[32m+[m[32m    @mock.patch('api.core.views.axl.Match.play')[m
[32m+[m[32m    def test_strategy_not_found(self, play, serializer):[m
[32m+[m[32m        mock_object = mock.MagicMock[m
[32m+[m[32m        mock_object.data = 'test'[m
[32m+[m
[32m+[m[32m        serializer.return_value = mock_object()[m
[32m+[m[32m        response = self.client.post('/matches/',[m
[32m+[m[32m                                    json.dumps(self.no_strategy_found),[m
[32m+[m[32m                                    content_type='application/json')[m
[32m+[m[32m        self.assertEqual({[m
[32m+[m[32m            'player_list': ['Ensure this field has at least 2 elements.']},[m
[32m+[m[32m            response.data)[m
[32m+[m[32m        self.assertEqual(400, response.status_code)[m
[32m+[m
[32m+[m[32m    @mock.patch('api.core.views.ResultsSerializer')[m
[32m+[m[32m    @mock.patch('api.core.views.axl.Match.play')[m
[32m+[m[32m    def test_invalid_field(self, play, serializer):[m
[32m+[m[32m        mock_object = mock.MagicMock[m
[32m+[m[32m        mock_object.data = 'test'[m
[32m+[m
[32m+[m[32m        serializer.return_value = mock_object()[m
[32m+[m[32m        response = self.client.post('/matches/',[m
[32m+[m[32m                                    json.dumps(self.missing_noise),[m
[32m+[m[32m                                    content_type='application/json')[m
[32m+[m[32m        self.assertEqual({'noise': ['This field is required.']}, response.data)[m
[32m+[m[32m        self.assertEqual(400, response.status_code)[m
[41m+[m
[41m+[m
[41m+[m
 [m
[1mdiff --git a/api/core/views.py b/api/core/views.py[m
[1mindex 7ffb17c..2f6127b 100644[m
[1m--- a/api/core/views.py[m
[1m+++ b/api/core/views.py[m
[36m@@ -66,15 +66,23 @@[m [mclass StrategyViewSet(viewsets.ViewSet):[m
         return Response(serializer.data)[m
 [m
 [m
[31m-class BaseTournamentView:[m
[32m+[m[32mclass BaseGameView(viewsets.ViewSet):[m
     """[m
[31m-[m
[32m+[m[32m    Base game object for ViewSets to inherit. Creates, retrieves and[m
[32m+[m[32m    cancels games.[m
     """[m
 [m
     strategies_index = {strategy_id(s): s for s in axl.strategies}[m
[31m-    _not_found_error = 'Strategy {} was not found'[m
[31m-[m
[31m-    def parse_players(self, player_list):[m
[32m+[m[32m    _not_found_error = 'Strategy {} was not found.'[m
[32m+[m
[32m+[m[32m    def _parse_players(self, player_list):[m
[32m+[m[32m        """[m
[32m+[m[32m        convert list of player strings into list of Strategies[m
[32m+[m[32m        Parameters[m
[32m+[m[32m        ----------[m
[32m+[m[32m            player_list: list of strings[m
[32m+[m[32m                a list of player ids[m
[32m+[m[32m        """[m
         players = [][m
         for player in player_list:[m
             strategy = self.strategies_index[player][m
[36m@@ -82,21 +90,36 @@[m [mclass BaseTournamentView:[m
         return players[m
 [m
     def create(self, request):[m
[31m-        data = request.data[m
[31m-        serializer = self.serializer(data=data)[m
[32m+[m[32m        """[m
[32m+[m[32m        POST method[m
[32m+[m
[32m+[m[32m        Take in a game_definition which expects all of the[m
[32m+[m[32m        required parameters of the type of game, a list of[m
[32m+[m[32m        player strings, and starts the game.[m
[32m+[m[32m        """[m
[32m+[m[32m        serializer = self.serializer(data=request.data)[m
         if serializer.is_valid():[m
[31m-            tournament_definition = serializer.data[m
[32m+[m[32m            game_definition = serializer.data[m
[32m+[m
             try:[m
[31m-                players = self.parse_players(data['player_list'])[m
[32m+[m[32m                players = self._parse_players(request.data['player_list'])[m
[32m+[m[32m                game_definition.pop('player_list')[m
             except KeyError as e:[m
[31m-                return Response({'player_list': self._not_found_error.format(e.args[0])})[m
[32m+[m[32m                return Response({[m
[32m+[m[32m                    'player_list': self._not_found_error.format(e.args[0])[m
[32m+[m[32m                }, 400)[m
 [m
[31m-            results = self.run(players, tournament_definition)[m
[31m-            return Response(ResultsSerializer(results).data, 200)[m
[32m+[m[32m            results = self.run(players, game_definition)[m
[32m+[m[32m            return Response(ResultsSerializer(results).data, 201)[m
         return Response(serializer.errors, 400)[m
 [m
 [m
[31m-class TournamentViewSet(viewsets.ViewSet, BaseTournamentView):[m
[32m+[m[32mclass TournamentViewSet(BaseGameView):[m
[32m+[m[32m    """[m
[32m+[m[32m    View that handles the creation and retrieval of tournaments. A[m
[32m+[m[32m    tournament consists of two or more players facing each other[m
[32m+[m[32m    in a round robin bout.[m
[32m+[m[32m    """[m
 [m
     serializer = TournamentSerializer[m
 [m
[36m@@ -106,7 +129,11 @@[m [mclass TournamentViewSet(viewsets.ViewSet, BaseTournamentView):[m
         return tournament.play()[m
 [m
 [m
[31m-class MatchViewSet(viewsets.ViewSet, BaseTournamentView):[m
[32m+[m[32mclass MatchViewSet(BaseGameView):[m
[32m+[m[32m    """[m
[32m+[m[32m    View that handles creation and retrieval of matches. A match[m
[32m+[m[32m    is a 1v1 game between two players.[m
[32m+[m[32m    """[m
 [m
     serializer = MatchSerializer[m
 [m
[36m@@ -114,3 +141,5 @@[m [mclass MatchViewSet(viewsets.ViewSet, BaseTournamentView):[m
     def run(players, definition):[m
         match = axl.Match(players=players, **definition)[m
         return match.play()[m
[41m+[m
[41m+[m
